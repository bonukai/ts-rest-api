import _ from 'lodash';
import { OpenAPIV3 } from 'openapi-types';
import path from 'path';
import Ajv from 'ajv';
import { existsSync, mkdirSync, writeFileSync } from 'fs';

import { Route } from './route';
import { generateOpenApiDocument } from './generators/openapi';
import { generateRoutes } from './generators/routes';
import { getRoutes } from './find_routes';
import configJsonSchema from './config_json_schema.json';
import { createExpressRoute, registerRoute, ValidationError } from './server';
export { createExpressRoute, registerRoute, ValidationError };

export class RouteValidationError extends Error {
  constructor(message?: string) {
    super(message);

    Object.setPrototypeOf(this, RouteValidationError.prototype);
  }
}
export class InvalidParamsType extends Error {
  constructor(message?: string) {
    super(message);

    Object.setPrototypeOf(this, InvalidParamsType.prototype);
  }
}

export type ConfigType = {
  openapi: Omit<
    OpenAPIV3.Document,
    | 'openapi'
    | 'paths'
    | 'components'
    | 'x-express-openapi-additional-middleware'
    | 'x-express-openapi-validation-strict'
  > & {
    components?: Omit<OpenAPIV3.ComponentsObject, 'schemas'>;
  };
  tsConfigPath?: string;
  schemaOutputDir?: string;
  schemaOutputFileName?: string;
  routesOutputDir?: string;
  routesOutputFileName?: string;
  generateOpenApiSchema?: boolean;
};

export const typedRestApi = (config: ConfigType) => {
  const ajv = new Ajv();

  if (!ajv.validate(configJsonSchema, config)) {
    throw new Error(
      `Invalid config file: ${ajv.errorsText(ajv.errors, {
        dataVar: 'Config',
      })}`
    );
  }

  overridePreviouslyGeneratedRoutesFile(config);

  const tsConfigPath =
    config.tsConfigPath || path.join(process.cwd(), 'tsconfig.json');

  const routes = getRoutes(tsConfigPath);

  if (config.generateOpenApiSchema ?? true) {
    _generateOpenApiDocument(config, routes);
  }

  _generateRoutes(config, routes);
};

const _generateOpenApiDocument = (config: ConfigType, routes: Route[]) => {
  const schemaOutputPath = path.join(
    config.schemaOutputDir || process.cwd(),
    config.schemaOutputFileName || 'openapi.json'
  );

  const generatedOpenApiSchema = generateOpenApiDocument(
    routes,
    config.openapi
  );

  if (!existsSync(path.dirname(schemaOutputPath))) {
    mkdirSync(path.dirname(schemaOutputPath), {
      recursive: true,
    });
  }

  writeFileSync(schemaOutputPath, generatedOpenApiSchema);

  console.log('Generated OpenApi schema to:', schemaOutputPath);
};

const _generateRoutes = (config: ConfigType, routes: Route[]) => {
  const routesOutputDir = path.join(
    config.routesOutputDir || path.join(process.cwd(), 'generated')
  );

  const routesOutputPath = path.join(
    routesOutputDir,
    config.routesOutputFileName || 'routes.ts'
  );

  const generatedRoutesFile = generateRoutes(routes, routesOutputDir);

  if (!existsSync(routesOutputDir)) {
    mkdirSync(routesOutputDir, {
      recursive: true,
    });
  }

  writeFileSync(routesOutputPath, generatedRoutesFile);

  console.log('Generated routes to:', routesOutputPath);
};

const overridePreviouslyGeneratedRoutesFile = (config: ConfigType) => {
  const routesOutputPath = path.join(
    config.routesOutputDir || path.join(process.cwd(), 'generated'),
    config.routesOutputFileName || 'routes.ts'
  );

  if (existsSync(routesOutputPath)) {
    writeFileSync(
      routesOutputPath,
      `// This file was generated by typescript-routes-to-openapi

import express, { Router } from 'express';

const router: Router = express.Router();

export { router as generatedRoutes };`
    );
  }
};
